/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: cb41f213-cc38-4873-ad83-66ec784bf671

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

def MordellHard840 (p : ℕ) : Prop :=
  p % 840 ∈ ({1, 121, 169, 289, 361, 529} : Set ℕ)

def mOfK (k : ℕ) : ℕ := 4 * k + 3
def xOfK (p k : ℕ) : ℕ := (p + mOfK k) / 4
def m (p x : ℕ) : ℕ := 4 * x - p

def TypeIIWitness (p x d : ℕ) : Prop :=
  (d ∣ x^2) ∧ d ≤ x ∧ Nat.ModEq (m p x) (d + x) 0

def d1Sufficient (k p : ℕ) : Prop := p % (16 * k + 12) = (12 * k + 5)

def PrimeFactorQR (m x : ℕ) : Prop :=
  ∀ q, q.Prime → q ∣ x → IsSquare (q : ZMod m)

def TargetNQR (m x : ℕ) : Prop :=
  ¬ IsSquare (-(x : ZMod m))

def QRSufficient (k p : ℕ) : Prop :=
  let m := mOfK k
  let x := xOfK p k
  ¬ (PrimeFactorQR m x ∧ TargetNQR m x)

def HasSolution (n : ℕ) : Prop :=
  ∃ x y z : ℕ, x > 0 ∧ y > 0 ∧ z > 0 ∧ 4 / (n : ℚ) = 1 / x + 1 / y + 1 / z

/-
When `p % (16*k + 12) = 12*k + 5`, prove that `d = 1` is a valid Type II witness.
-/
theorem d1Sufficient_witness
    (k p : ℕ) (hp : Nat.Prime p) (hMH : MordellHard840 p)
    (hsuff : d1Sufficient k p) :
    TypeIIWitness p (xOfK p k) 1 := by
      refine' ⟨ _, _, _ ⟩ <;> norm_num [ d1Sufficient ] at *;
      · exact Nat.div_pos ( by linarith [ Nat.Prime.two_le hp, Nat.zero_le k, Nat.mod_le p ( 16 * k + 12 ), hsuff ] ) zero_lt_four;
      · -- By definition of $xOfK$, we have $xOfK p k = (p + (4 * k + 3)) / 4$.
        have hxOfK : xOfK p k = (p + (4 * k + 3)) / 4 := by
          rfl;
        -- By definition of $mOfK$, we have $m p (xOfK p k) = 4 * (xOfK p k) - p$.
        have hmOfK : m p (xOfK p k) = 4 * (xOfK p k) - p := by
          rfl;
        rw [ Nat.modEq_zero_iff_dvd, hmOfK ];
        rw [ hxOfK, Nat.mul_div_cancel' ];
        · rw [ ← Nat.mod_add_div p ( 16 * k + 12 ), hsuff ] ; ring_nf ; (
          norm_num [ show 8 + k * 16 + k * ( p / ( 12 + k * 16 ) ) * 16 + p / ( 12 + k * 16 ) * 12 = ( 5 + k * 12 + k * ( p / ( 12 + k * 16 ) ) * 16 + p / ( 12 + k * 16 ) * 12 ) + ( 3 + k * 4 ) by ring ];
          exact ⟨ 1 + ( p / ( 12 + k * 16 ) ) * 1, by linarith [ Nat.div_mul_cancel ( show 4 ∣ 5 + k * 12 + k * ( p / ( 12 + k * 16 ) ) * 16 + p / ( 12 + k * 16 ) * 12 + ( 3 + k * 4 ) from Nat.dvd_of_mod_eq_zero ( by norm_num [ Nat.add_mod, Nat.mul_mod ] ) ) ] ⟩);
        · exact Nat.dvd_of_mod_eq_zero ( by rw [ ← Nat.mod_add_div p ( 16 * k + 12 ), hsuff ] ; ring_nf; norm_num [ Nat.add_mod, Nat.mul_mod ] )

/-
If a Type II witness exists, then the Erdős-Straus conjecture has a solution for p.
-/
theorem TypeIIWitness_implies_HasSolution
    (p x d : ℕ) (hp : Nat.Prime p) (hx : x > 0) (h : TypeIIWitness p x d) : HasSolution p := by
  rcases h with ⟨hd_dvd_x2, hd_le_x, h_mod⟩
  let m := 4 * x - p
  have hm_dvd : m ∣ d + x := by
    rw [← Nat.modEq_zero_iff_dvd]
    exact h_mod
  have hm_pos : m > 0 := by
    -- m = 4x - p. Since x = (p + mOfK)/4, 4x = p + mOfK > p.
    exact Nat.pos_of_dvd_of_pos hm_dvd ( by linarith ) |> fun h => by contrapose! h; aesop;
  rcases hm_dvd with ⟨k, hk_eq⟩
  -- hk_eq : d + x = m * k
  rw [mul_comm] at hk_eq
  -- hk_eq : d + x = k * m
  have hk_pos : k > 0 := by
    -- d + x > 0 and m > 0 implies k > 0
    grind
  let z := p * k
  let y := p * x * k / d
  have hy_int : d ∣ p * x * k := by
    -- d | x^2 and d + x = k * m implies d | p * x * k
    -- Since $d \mid x^2$, we have $d \mid xk$ (because $k$ is an integer).
    have hd_dvd_xk : d ∣ x * k := by
      have hd_dvd_xk : d ∣ x * (d + x) := by
        convert dvd_add hd_dvd_x2 ( dvd_mul_right d x ) using 1 ; ring;
      simp_all +decide [ mul_assoc, Nat.Prime.dvd_mul ];
      have hd_coprime_mk : Nat.gcd d (4 * x - p) = 1 := by
        refine' Nat.Coprime.coprime_dvd_left hd_dvd_x2 _;
        -- Since $p$ is prime and $p \equiv 3 \pmod{4}$, we have $\gcd(x, 4x - p) = \gcd(x, p) = 1$.
        have h_coprime : Nat.gcd x p = 1 := by
          refine' Nat.Coprime.symm ( hp.coprime_iff_not_dvd.mpr _ );
          intro h; have := Nat.le_of_dvd ( by positivity ) h; rcases k with ( _ | _ | k ) <;> simp_all +decide [ Nat.mul_succ ] ;
          · grind +ring;
          · grind;
        cases le_total ( 4 * x ) p <;> simp_all +decide [ Nat.Coprime, Nat.gcd_comm ];
        grind;
      exact ( Nat.Coprime.dvd_of_dvd_mul_right hd_coprime_mk <| by convert hd_dvd_xk using 1; ring );
    exact dvd_trans hd_dvd_xk ⟨ p, by ring ⟩
  have hy_val : y * d = p * x * k := by
    rw [Nat.div_mul_cancel hy_int]
  have h_sol : 4 / (p : ℚ) = 1 / x + 1 / y + 1 / z := by
    -- Algebraic verification
    -- Combine the terms on the right-hand side over a common denominator.
    have h_common_denom : 1 / (x : ℚ) + 1 / (y : ℚ) + 1 / (z : ℚ) = (y * z + x * z + x * y) / (x * y * z) := by
      rw [ div_add_div, div_add_div ] <;> ring <;> aesop;
    -- Substitute the values of $y$ and $z$ into the common denominator.
    have h_substitute : (y * z + x * z + x * y : ℚ) = (p * x * k / d) * (p * k) + x * (p * k) + x * (p * x * k / d) := by
      rw [ Nat.cast_div ] <;> norm_cast ; aesop;
    rw [h_common_denom, h_substitute];
    rw [ div_eq_div_iff ] <;> norm_cast <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
    · zify at *;
      grind;
    · exact hp.ne_zero;
    · exact ⟨ hx.ne', mul_ne_zero hp.ne_zero hk_pos.ne', Nat.ne_of_gt ( Nat.pos_of_ne_zero fun h => by simp_all +decide [ ne_of_gt ] ) ⟩
  use x, y, z
  refine ⟨hx, ?_, ?_, h_sol⟩
  · -- y > 0
    -- Since $d$ divides $p * x * k$ and $d > 0$, it follows that $y = \frac{p * x * k}{d}$ is a positive integer.
    have hy_pos : y > 0 := by
      have h_div : d ∣ p * x * k := hy_int
      have h_pos : 0 < p * x * k := by
        exact Nat.mul_pos ( Nat.mul_pos hp.pos hx ) hk_pos
      exact Nat.div_pos ( Nat.le_of_dvd h_pos h_div ) ( Nat.pos_of_dvd_of_pos hd_dvd_x2 ( pow_pos hx 2 ) );
    exact hy_pos
  · -- z > 0
    -- Since $p$ is a prime number and $k$ is a positive integer, their product $z = p * k$ is also positive.
    apply mul_pos hp.pos hk_pos

/-
For Mordell-hard primes, the modulus m(p, x) equals mOfK k.
-/
lemma m_eq_mOfK (k p : ℕ) (hMH : MordellHard840 p) : m p (xOfK p k) = mOfK k := by
  -- By definition of $MordellHard840$, we know that $p \mod 840 \in \{1, 121, 169, 289, 361, 529\}$.
  obtain ⟨hp_mod⟩ := hMH
  have hp_mod_eq : p % 4 = 1 := by
    norm_num [ ← Nat.mod_mod_of_dvd p ( by decide : 4 ∣ 840 ), hp_mod ];
  · exact Nat.sub_eq_of_eq_add <| by unfold xOfK mOfK; omega;
  · unfold m xOfK mOfK; ring;
    grind

/-
If there exists a divisor d of x^2 such that d + x ≡ 0 (mod m), then there exists a Type II witness.
-/
theorem Witness_congruence_implies_TypeIIWitness
    (p x : ℕ) (m : ℕ) (hm : m = 4 * x - p) (hgcd : Nat.gcd x m = 1)
    (h_cong : ∃ d, d ∣ x^2 ∧ Nat.ModEq m (d + x) 0) :
    ∃ d', TypeIIWitness p x d' := by
      obtain ⟨d, hd_div, hd_cong⟩ := h_cong
      generalize_proofs at *;
      by_cases hdx : d ≤ x;
      · refine' ⟨ d, hd_div, hdx, _ ⟩;
        convert hd_cong using 1;
        exact hm.symm ▸ rfl;
      · -- Let $d' = x^2 / d$. Since $d \mid x^2$, $d'$ is an integer and $d' \leq x$.
        set d' : ℕ := x^2 / d
        have hd'_le_x : d' ≤ x := by
          exact Nat.div_le_of_le_mul <| by nlinarith;
        have hd'_div : d' ∣ x^2 := by
          exact Nat.div_dvd_of_dvd hd_div
        have hd'_cong : d' + x ≡ 0 [MOD m] := by
          have hd'_cong : d * d' ≡ x^2 [MOD m] := by
            rw [ Nat.mul_div_cancel' hd_div ];
          have hd'_cong : d * (d' + x) ≡ 0 [MOD m] := by
            simp_all +decide [ ← ZMod.natCast_eq_natCast_iff, mul_add ];
            linear_combination' hd_cong * x;
          rw [ Nat.modEq_zero_iff_dvd ] at *;
          refine' Nat.Coprime.dvd_of_dvd_mul_left _ hd'_cong;
          exact Nat.Coprime.symm ( Nat.Coprime.coprime_dvd_left hd_div <| by simpa [ Nat.coprime_comm ] using hgcd )
        use d';
        unfold TypeIIWitness; aesop;