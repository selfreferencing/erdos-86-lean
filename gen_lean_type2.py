#!/usr/bin/env python3
"""Generate Lean 4 Type2Cert data file from witness CSV.

Usage:
    python3 gen_lean_type2.py [B]

    B = upper bound (default 1000000). Reads witnesses_B.csv and produces
    ErdosStraus/ED2/Type2CertData.lean.

This generates three files:
1. Type2Data.lean      - structure + predicate definitions
2. Type2CertData.lean  - the witness list (auto-generated)
3. Type2Covering.lean  - verification theorems (template)
"""

import csv
import sys
import os


def read_witnesses(csvfile):
    """Read (p, offset, b, c) from CSV."""
    witnesses = []
    with open(csvfile) as f:
        reader = csv.DictReader(f)
        for row in reader:
            witnesses.append((
                int(row['p']),
                int(row['offset']),
                int(row['b']),
                int(row['c'])
            ))
    return sorted(witnesses)


def verify_witness(p, offset, b, c):
    """Verify the Type II identity in Python."""
    assert offset % 4 == 3, f"offset%4={offset%4} for p={p}"
    assert b > 0, f"b=0 for p={p}"
    assert c > 0, f"c=0 for p={p}"
    lhs = (p + offset) * (b + c)
    rhs = 4 * offset * b * c
    assert lhs == rhs, f"Identity fails for p={p}: {lhs} != {rhs}"


def gen_type2_data_lean(outdir):
    """Generate Type2Data.lean with structure and predicate."""
    lines = [
        "/-",
        "  Type II Certificate Data Structures",
        "  =====================================",
        "",
        "  Defines the Type2Cert structure and Type2CertOK validity predicate",
        "  for computational verification of sorry-region primes.",
        "-/",
        "",
        "import Mathlib.Tactic",
        "",
        "namespace ED2",
        "",
        "/-- Certificate for a sorry-region prime: (p, offset, b, c) satisfying",
        "    offset % 4 = 3, b > 0, c > 0, (p+offset)(b+c) = 4*offset*b*c. -/",
        "structure Type2Cert where",
        "  p : \u2115",
        "  offset : \u2115",
        "  b : \u2115",
        "  c : \u2115",
        "deriving DecidableEq, Repr",
        "",
        "/-- Validity predicate: all four conditions checkable in \u2115. -/",
        "def Type2CertOK (cert : Type2Cert) : Prop :=",
        "  cert.offset % 4 = 3 \u2227",
        "  cert.b > 0 \u2227",
        "  cert.c > 0 \u2227",
        "  (cert.p + cert.offset) * (cert.b + cert.c) = 4 * cert.offset * cert.b * cert.c",
        "",
        "/-- Decidable instance for native_decide. -/",
        "instance (cert : Type2Cert) : Decidable (Type2CertOK cert) := by",
        "  unfold Type2CertOK",
        "  infer_instance",
        "",
        "end ED2",
    ]
    outfile = os.path.join(outdir, "Type2Data.lean")
    with open(outfile, "w") as f:
        f.write("\n".join(lines) + "\n")
    print(f"Wrote {outfile} ({len(lines)} lines)")


def gen_type2_cert_data_lean(witnesses, B, outdir):
    """Generate Type2CertData.lean with the witness list."""
    lines = [
        "/-",
        f"  Auto-generated Type II witness data for sorry-region primes up to {B}.",
        f"  Total entries: {len(witnesses)}",
        "",
        "  Generated by gen_lean_type2.py",
        "  Each entry (p, offset, b, c) satisfies:",
        "    offset % 4 = 3, b > 0, c > 0,",
        "    (p + offset) * (b + c) = 4 * offset * b * c",
        "-/",
        "",
        "import ErdosStraus.ED2.Type2Data",
        "",
        "namespace ED2",
        "",
        f"/-- Witnesses for all {len(witnesses)} sorry-region primes up to {B}. -/",
        "def type2Certs : List Type2Cert :=",
        "[",
    ]

    for i, (p, offset, b, c) in enumerate(witnesses):
        comma = "," if i < len(witnesses) - 1 else ""
        lines.append(
            f"  {{ p := {p}, offset := {offset}, b := {b}, c := {c} }}{comma}"
        )

    lines.extend([
        "]",
        "",
        "end ED2",
    ])

    outfile = os.path.join(outdir, "Type2CertData.lean")
    with open(outfile, "w") as f:
        f.write("\n".join(lines) + "\n")
    print(f"Wrote {outfile} ({len(lines)} lines)")


def gen_type2_covering_lean(B, outdir):
    """Generate Type2Covering.lean template with verification theorems."""
    lines = [
        "/-",
        "  Type II Certificate Verification",
        "  =================================",
        "",
        "  Proves all stored Type II certificates are valid via native_decide,",
        "  and provides bridge theorems to connect to the sorry in Existence.lean.",
        "-/",
        "",
        "import ErdosStraus.ED2.Type2Data",
        "import ErdosStraus.ED2.Type2CertData",
        "import Mathlib.Tactic",
        "",
        "namespace ED2",
        "",
        "/-- All stored Type II certificates satisfy the validity predicate. -/",
        "theorem type2_certs_all_ok : List.Forall Type2CertOK type2Certs := by",
        "  native_decide",
        "",
        "/-- A valid Type II cert gives an existential witness (with \u2124 identity). -/",
        "theorem type2_cert_ok_gives_witness (cert : Type2Cert) (h : Type2CertOK cert) :",
        "    \u2203 offset b c : \u2115,",
        "      offset % 4 = 3 \u2227 b > 0 \u2227 c > 0 \u2227",
        "      (\u2191cert.p + \u2191offset : \u2124) * (\u2191b + \u2191c) = 4 * \u2191offset * \u2191b * \u2191c := by",
        "  refine \u27e8cert.offset, cert.b, cert.c, h.1, h.2.1, h.2.2.1, ?_\u27e9",
        "  -- Bridge: \u2115 identity => \u2124 identity",
        "  have hnat := h.2.2.2",
        "  exact_mod_cast hnat",
        "",
        f"-- To use: for each sorry-region prime p \u2264 {B}, look up its cert,",
        "-- verify via type2_certs_all_ok, and extract via type2_cert_ok_gives_witness.",
        "",
        "end ED2",
    ]

    outfile = os.path.join(outdir, "Type2Covering.lean")
    with open(outfile, "w") as f:
        f.write("\n".join(lines) + "\n")
    print(f"Wrote {outfile} ({len(lines)} lines)")


def main():
    B = int(sys.argv[1]) if len(sys.argv) > 1 else 1000000

    base = "/Users/kvallie2/Desktop/esc_stage8"
    csvfile = os.path.join(base, f"witnesses_{B}.csv")
    outdir = os.path.join(base, "ErdosStraus", "ED2")

    if not os.path.exists(csvfile):
        print(f"ERROR: {csvfile} not found. Run gen_witnesses.py {B} first.")
        sys.exit(1)

    print(f"Reading witnesses from {csvfile}...")
    witnesses = read_witnesses(csvfile)
    print(f"Read {len(witnesses)} witnesses")

    # Verify all witnesses
    print("Verifying all witnesses...")
    for p, offset, b, c in witnesses:
        verify_witness(p, offset, b, c)
    print("All witnesses verified.")

    # Generate Lean files
    gen_type2_data_lean(outdir)
    gen_type2_cert_data_lean(witnesses, B, outdir)
    gen_type2_covering_lean(B, outdir)

    print(f"\nDone. Generated 3 Lean files in {outdir}/")
    print(f"Next steps:")
    print(f"  1. Add the files to your lakefile.lean if needed")
    print(f"  2. Run 'lake build' to verify native_decide passes")
    print(f"  3. Connect to the sorry in Existence.lean (see blueprint Section 9.5)")


if __name__ == "__main__":
    main()
