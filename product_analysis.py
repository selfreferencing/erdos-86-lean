#!/usr/bin/env python3
"""
Analyze whether products of primes cover the 17 remaining cases.

Key insight: If x_k = 2^a × 3^b × ..., then divisors include products 2^i × 3^j.
The subgroup ⟨2, 3⟩ mod m_k might be larger than ⟨2⟩ or ⟨3⟩ alone.
"""

from math import gcd

K10 = [5, 7, 9, 11, 14, 17, 19, 23, 26, 29]
UNCOVERED = [6, 8, 12, 18, 26, 36, 48, 62, 78, 96, 116, 122, 138, 146, 158, 162, 188]

def m_k(k):
    return 4 * k + 3

def euler_phi(n):
    result = n
    temp = n
    p = 2
    while p * p <= temp:
        if temp % p == 0:
            while temp % p == 0:
                temp //= p
            result -= result // p
        p += 1
    if temp > 1:
        result -= result // temp
    return result

def subgroup_generated(generators, m):
    """Compute the subgroup of (Z/m)× generated by the given elements."""
    if not generators:
        return {1}

    subgroup = {1}
    frontier = set(g % m for g in generators if gcd(g, m) == 1)
    subgroup.update(frontier)

    while frontier:
        new_elts = set()
        for g in list(subgroup):
            for h in frontier:
                prod = (g * h) % m
                if prod not in subgroup:
                    new_elts.add(prod)
        if not new_elts:
            break
        subgroup.update(new_elts)
        frontier = new_elts

    return subgroup

print("=" * 70)
print("SUBGROUP ANALYSIS: ⟨2, 3⟩ mod m_k")
print("=" * 70)
print()

for k in K10:
    m = m_k(k)
    phi = euler_phi(m)

    sg_2 = subgroup_generated([2], m)
    sg_3 = subgroup_generated([3], m)
    sg_23 = subgroup_generated([2, 3], m)

    print(f"k={k:2d}, m_k={m:3d}, φ(m_k)={phi:3d}:")
    print(f"  |⟨2⟩| = {len(sg_2):3d}, index = {phi // len(sg_2)}")
    print(f"  |⟨3⟩| = {len(sg_3):3d}, index = {phi // len(sg_3)}")
    print(f"  |⟨2,3⟩| = {len(sg_23):3d}, index = {phi // len(sg_23)}")
    if len(sg_23) == phi:
        print(f"  → ⟨2,3⟩ = (Z/{m})× ✓")
    print()

print("=" * 70)
print("ANALYSIS OF UNCOVERED CASES")
print("=" * 70)
print()

offsets = {k: k - 5 for k in K10}

for n_mod_210 in UNCOVERED:
    print(f"n ≡ {n_mod_210} (mod 210):")

    covered = False
    witnesses = []

    for k in K10:
        m = m_k(k)
        offset = offsets[k]
        x_k_mod = (n_mod_210 + offset) % 210

        # Find small prime factors of x_k
        factors = []
        temp = x_k_mod
        if temp == 0:
            temp = 210  # Handle x_k ≡ 0 (mod 210)
        for p in [2, 3, 5, 7, 11, 13]:
            if temp % p == 0:
                factors.append(p)

        # Check if these factors generate (Z/m)×
        valid_factors = [f for f in factors if gcd(f, m) == 1]
        if valid_factors:
            sg = subgroup_generated(valid_factors, m)
            phi = euler_phi(m)

            if len(sg) == phi:
                witnesses.append((k, m, factors, "full"))
                covered = True
            elif len(sg) >= phi // 2:
                witnesses.append((k, m, factors, f"|sg|={len(sg)}, index={phi // len(sg)}"))

    if covered:
        print(f"  COVERED by factor products:")
        for k, m, factors, status in witnesses:
            if status == "full":
                print(f"    k={k}: ⟨{factors}⟩ = (Z/{m})×")
    else:
        print(f"  NOT COVERED by small prime products")
        for k, m, factors, status in witnesses:
            print(f"    k={k}: ⟨{factors}⟩ mod {m}: {status}")

    print()

# Detailed check with more primes
print("=" * 70)
print("EXTENDED ANALYSIS WITH PRIMES UP TO 23")
print("=" * 70)
print()

PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23]

for n_mod_210 in UNCOVERED:
    print(f"n ≡ {n_mod_210} (mod 210):")

    for k in K10:
        m = m_k(k)
        offset = offsets[k]
        x_k_mod = (n_mod_210 + offset) % 210

        # For larger analysis, we need x_k mod larger numbers
        # But x_k = n + offset, so x_k mod p for prime p depends on n mod p
        n_mod_p = {p: n_mod_210 % p for p in PRIMES}

        factors = []
        for p in PRIMES:
            # p | x_k iff (n + offset) ≡ 0 (mod p)
            if (n_mod_p[p] + offset) % p == 0:
                factors.append(p)

        valid_factors = [f for f in factors if gcd(f, m) == 1]
        if valid_factors:
            sg = subgroup_generated(valid_factors, m)
            phi = euler_phi(m)

            if len(sg) == phi:
                print(f"  k={k}: ⟨{valid_factors}⟩ = (Z/{m})× ✓")
                break
    else:
        print(f"  Still not covered by primes up to 23")

    print()

# Final summary
print("=" * 70)
print("PROOF STRATEGY SUMMARY")
print("=" * 70)
print()
print("For each n mod 210, we need to show that at least one k ∈ K10")
print("has x_k with prime factors that generate (Z/m_k)×.")
print()
print("This can be verified by:")
print("1. Computing the subgroup generated by prime factors of x_k for each k")
print("2. Checking if any k has ⟨factors⟩ = (Z/m_k)×")
print()
print("If true for all 210 cases, then for any n, we have a witness.")
print("The witness d is a product of prime powers that equals -x_k (mod m_k).")
