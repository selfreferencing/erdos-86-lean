#!/usr/bin/env python3
"""
Meta-analysis of K13 failures: WHY do these 14 primes fail?
"""

from math import gcd, isqrt
from collections import defaultdict

K13 = [0, 1, 2, 5, 7, 9, 11, 14, 17, 19, 23, 26, 29]
M_K = {k: 4*k + 3 for k in K13}

# The 14 K13 failures up to 50 million
FAILURES = [
    10170169, 11183041, 22605361, 24966481, 30573481, 30619801,
    34103161, 35241529, 36851929, 36869281, 37228801, 45575401,
    46936849, 48991849
]

def factor(n):
    """Return list of (prime, exponent) pairs."""
    factors = []
    d = 2
    temp = n
    while d * d <= temp:
        if temp % d == 0:
            e = 0
            while temp % d == 0:
                e += 1
                temp //= d
            factors.append((d, e))
        d += 1
    if temp > 1:
        factors.append((temp, 1))
    return factors

def radical(n):
    """Product of distinct prime factors."""
    return prod(p for p, e in factor(n))

def prod(iterable):
    result = 1
    for x in iterable:
        result *= x
    return result

def x_k(p, k):
    m = M_K[k]
    return (p + m) // 4

def analyze_failure(p):
    """Deep analysis of why prime p fails K13."""
    print(f"\n{'='*70}")
    print(f"PRIME p = {p}")
    print(f"{'='*70}")
    print(f"p mod 840 = {p % 840}")
    print(f"p mod 210 = {p % 210}")
    print(f"p mod 30 = {p % 30}")

    t = (p + 3) // 4
    print(f"t = (p+3)/4 = {t}")
    print(f"t mod 210 = {t % 210}")

    print(f"\nFor each k in K13:")
    print(f"{'k':>3} | {'m_k':>4} | {'x_k':>10} | {'factors':30} | {'-x_k mod m_k':>12} | {'obstruction'}")
    print("-" * 90)

    all_obstructions = []

    for k in K13:
        mk = M_K[k]
        xk = x_k(p, k)
        facts = factor(xk)
        facts_str = " × ".join(f"{p}^{e}" if e > 1 else str(p) for p, e in facts)
        target = (-xk) % mk
        if target == 0:
            target = mk

        # Check what's blocking: compute subgroup generated by prime factors
        prime_residues = [(q, q % mk) for q, e in facts if gcd(q, mk) == 1]

        # Generate subgroup from these residues
        generated = {1}
        for q, r in prime_residues:
            new = set()
            for g in generated:
                power = 1
                for _ in range(mk):
                    power = (power * r) % mk
                    if power == 0:
                        break
                    new.add((g * power) % mk)
            generated.update(new)

        # Is target in generated subgroup?
        in_subgroup = target in generated
        obstruction = "WITNESS POSSIBLE" if in_subgroup else f"BLOCKED (target {target} not in H)"

        if not in_subgroup:
            all_obstructions.append((k, mk, target, generated, prime_residues))

        print(f"{k:>3} | {mk:>4} | {xk:>10} | {facts_str:30} | {target:>12} | {obstruction}")

    # Summary of obstructions
    print(f"\nOBSTRUCTION ANALYSIS:")
    print(f"All {len(K13)} values of k are blocked.")

    # Look for common structure
    print(f"\nPrime factor analysis:")
    all_primes = set()
    for k in K13:
        xk = x_k(p, k)
        for q, e in factor(xk):
            all_primes.add(q)

    print(f"Distinct primes across all x_k: {sorted(all_primes)}")
    print(f"Count: {len(all_primes)}")

    # Check for small prime factors
    small_primes = [q for q in all_primes if q <= 29]
    large_primes = [q for q in all_primes if q > 29]
    print(f"Small primes (≤29): {small_primes}")
    print(f"Large primes (>29): {large_primes}")

    return {
        'p': p,
        'p_mod_840': p % 840,
        't': t,
        't_mod_210': t % 210,
        'all_primes': all_primes,
        'large_primes': large_primes
    }

def find_common_patterns(analyses):
    """Look for patterns across all failures."""
    print(f"\n{'='*70}")
    print("CROSS-FAILURE PATTERN ANALYSIS")
    print(f"{'='*70}")

    # Residue classes
    print("\n1. RESIDUE CLASS DISTRIBUTION:")
    mod_840 = defaultdict(list)
    mod_210 = defaultdict(list)
    for a in analyses:
        mod_840[a['p_mod_840']].append(a['p'])
        mod_210[a['t_mod_210']].append(a['p'])

    print(f"   p mod 840: {dict(mod_840)}")
    print(f"   t mod 210: {dict(mod_210)}")

    # Check for finer moduli
    print("\n2. FINER MODULI CHECK:")
    for mod in [2520, 5040, 7560, 10080]:
        residues = defaultdict(list)
        for a in analyses:
            residues[a['p'] % mod].append(a['p'])
        if len(residues) < len(analyses):
            print(f"   mod {mod}: {len(residues)} distinct classes (clustering!)")
            for r, ps in sorted(residues.items()):
                if len(ps) > 1:
                    print(f"      {r}: {ps}")

    # Large prime analysis
    print("\n3. LARGE PRIME STRUCTURE:")
    for a in analyses:
        print(f"   p={a['p']}: large primes = {sorted(a['large_primes'])}")

    # GCD analysis between failures
    print("\n4. GCD BETWEEN FAILURE PRIMES:")
    gcds = []
    for i, a1 in enumerate(analyses):
        for a2 in analyses[i+1:]:
            g = gcd(a1['p'], a2['p'])
            if g > 1:
                gcds.append((a1['p'], a2['p'], g))
    if gcds:
        print(f"   Non-trivial GCDs: {gcds}")
    else:
        print(f"   All pairwise coprime (expected for distinct primes)")

    # Difference analysis
    print("\n5. DIFFERENCES BETWEEN CONSECUTIVE FAILURES:")
    sorted_failures = sorted(a['p'] for a in analyses)
    diffs = [sorted_failures[i+1] - sorted_failures[i] for i in range(len(sorted_failures)-1)]
    print(f"   Gaps: {diffs}")
    print(f"   Min gap: {min(diffs)}, Max gap: {max(diffs)}, Avg: {sum(diffs)/len(diffs):.0f}")

def test_k_extensions(failures, max_k=50):
    """Test if adding other k values would cover the failures."""
    print(f"\n{'='*70}")
    print("K EXTENSION ANALYSIS: What k values would cover these failures?")
    print(f"{'='*70}")

    def has_witness(p, k):
        m = 4*k + 3
        x = (p + m) // 4
        target = (-x) % m
        if target == 0:
            target = m
        x_sq = x * x
        d = target
        while d <= x:
            if d > 0 and x_sq % d == 0:
                return True
            d += m
        return False

    # For each k not in K13, check how many failures it covers
    k13_set = set(K13)
    coverage = {}

    for k in range(max_k + 1):
        if k in k13_set:
            continue
        covered = [p for p in failures if has_witness(p, k)]
        if covered:
            coverage[k] = covered

    print(f"\nk values (not in K13) that cover at least one failure:")
    for k, covered in sorted(coverage.items(), key=lambda x: -len(x[1])):
        print(f"   k={k} (m_k={4*k+3}): covers {len(covered)}/{len(failures)} failures")
        print(f"      {covered}")

    # Find minimal extension
    print(f"\nGREEDY MINIMAL EXTENSION:")
    uncovered = set(failures)
    extension = []
    while uncovered:
        best_k = None
        best_covers = []
        for k, covered in coverage.items():
            if k in extension:
                continue
            covers_uncovered = [p for p in covered if p in uncovered]
            if len(covers_uncovered) > len(best_covers):
                best_k = k
                best_covers = covers_uncovered

        if best_k is None:
            print(f"   Cannot cover remaining {len(uncovered)} failures with k ≤ {max_k}")
            print(f"   Uncovered: {sorted(uncovered)}")
            break

        extension.append(best_k)
        for p in best_covers:
            uncovered.discard(p)
        print(f"   Add k={best_k}: covers {best_covers}, {len(uncovered)} remaining")

    if not uncovered:
        print(f"\n   K13 + {{{', '.join(map(str, extension))}}} covers all 14 failures!")
        print(f"   New set size: {len(K13) + len(extension)}")

def main():
    print("K13 FAILURE META-ANALYSIS")
    print("=" * 70)
    print(f"Analyzing {len(FAILURES)} K13 failures\n")

    # Detailed analysis of each failure
    analyses = []
    for p in FAILURES:
        analyses.append(analyze_failure(p))

    # Cross-failure patterns
    find_common_patterns(analyses)

    # K extension analysis
    test_k_extensions(FAILURES, max_k=100)

if __name__ == "__main__":
    main()
