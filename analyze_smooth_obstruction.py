#!/usr/bin/env python3
"""
Deep analysis of WHY the smooth framework fails on K13 failures.

Key insight: The issue is NOT that -1 ∉ H for the full H.
The issue is that x_k has a RESTRICTED prime support, generating
a SMALL subgroup H(s) that doesn't contain -1.

This directly connects to the Dirichlet character obstruction!
"""

from math import gcd, isqrt

K13 = [0, 1, 2, 5, 7, 9, 11, 14, 17, 19, 23, 26, 29]
M_K = {k: 4*k + 3 for k in K13}

FAILURES = [
    10170169, 11183041, 22605361, 24966481, 30573481, 30619801,
    34103161, 35241529, 36851929, 36869281, 37228801, 45575401,
    46936849, 48991849
]

def factor(n):
    factors = []
    d = 2
    temp = n
    while d * d <= temp:
        if temp % d == 0:
            e = 0
            while temp % d == 0:
                e += 1
                temp //= d
            factors.append((d, e))
        d += 1
    if temp > 1:
        factors.append((temp, 1))
    return factors

def x_k(p, k):
    m = M_K[k]
    return (p + m) // 4

def subgroup_generated_with_exponents(prime_exp_list, m):
    """
    Generate the set of residues reachable from divisors.
    For prime^e, we can use exponents 0, 1, ..., 2e.
    """
    reachable = {1}
    for p, e in prime_exp_list:
        if gcd(p, m) > 1:
            continue
        r = p % m
        new = set()
        for h in reachable:
            power = 1
            for exp in range(2*e + 1):  # 0 to 2e
                new.add((h * power) % m)
                power = (power * r) % m
        reachable = new
    return reachable

def subgroup_generated(primes, m):
    """Generate full multiplicative subgroup from primes (any exponent)."""
    H = {1}
    for p in primes:
        if gcd(p, m) > 1:
            continue
        r = p % m
        if r == 0:
            continue
        new = set()
        for h in H:
            power = 1
            seen = set()
            while power not in seen:
                seen.add(power)
                new.add((h * power) % m)
                power = (power * r) % m
        H.update(new)
    return H

def analyze_obstruction_structure():
    """
    For each failure and each k in K13, show:
    1. The prime factorization of x_k
    2. The subgroup H(x_k) generated by ALL prime factors
    3. Whether -1 ∈ H(x_k)
    4. The divisor residue set (limited by exponents)
    """
    print("=" * 80)
    print("SMOOTH FRAMEWORK ↔ CHARACTER OBSTRUCTION CONNECTION")
    print("=" * 80)

    for k in [0, 1, 2]:  # Focus on the "universal" k values
        mk = M_K[k]
        G_size = sum(1 for a in range(1, mk) if gcd(a, mk) == 1)
        neg1 = (-1) % mk

        print(f"\n{'='*80}")
        print(f"k={k}, m_k={mk}, G = (Z/{mk}Z)*, |G| = {G_size}")
        print(f"Target for witness: need -x ≡ some divisor of x², i.e., -1 ∈ H(x)")
        print("=" * 80)

        for p in FAILURES[:5]:  # First 5 for brevity
            xk = x_k(p, k)
            facts = factor(xk)
            primes = [q for q, e in facts]
            target = (-xk) % mk

            # Subgroup from ALL prime factors (unlimited exponents)
            H_full = subgroup_generated(primes, mk)

            # Actual divisor residues (limited by exponents in factorization)
            div_residues = subgroup_generated_with_exponents(facts, mk)

            # Check -1 in subgroup
            neg1_in_H = neg1 in H_full

            # Residues of the primes
            prime_residues = [(q, q % mk) for q in primes]

            print(f"\n  p={p}: x_{k} = {xk}")
            print(f"    Factorization: {' × '.join(f'{q}^{e}' if e > 1 else str(q) for q, e in facts)}")
            print(f"    Prime residues mod {mk}: {prime_residues}")
            print(f"    H(x) = ⟨primes⟩: size {len(H_full)}, elements = {sorted(H_full) if len(H_full) <= 10 else '...'}")
            print(f"    -1 = {neg1} ∈ H(x): {neg1_in_H}")
            print(f"    Div(x²) residues: size {len(div_residues)}")
            print(f"    Target {target} ∈ Div(x²): {target in div_residues}")

            if not neg1_in_H:
                # This is the CHARACTER OBSTRUCTION
                print(f"    → CHARACTER OBSTRUCTION: primes generate subgroup not containing -1")

def show_character_connection():
    """
    Show explicitly that the smooth framework obstruction IS the character obstruction.
    """
    print("\n" + "=" * 80)
    print("THE KEY INSIGHT: SMOOTH FRAMEWORK = CHARACTER OBSTRUCTION")
    print("=" * 80)

    print("""
For k=0 (m=3):
  - G = (Z/3Z)* = {1, 2}
  - -1 = 2 (mod 3)
  - Character kernel (primes ≡ 1 mod 3) generates H = {1}
  - Obstruction: 2 ∉ {1}, so no witness

For k=1 (m=7):
  - G = (Z/7Z)* = {1, 2, 3, 4, 5, 6}
  - QR(7) = {1, 2, 4} (index 2 subgroup)
  - -1 = 6 (mod 7) is a NON-QR
  - If all prime factors of x_1 are QRs, H ⊆ QR(7)
  - Obstruction: 6 ∉ QR(7), so no witness

For k=2 (m=11):
  - G = (Z/11Z)* = {1, 2, ..., 10}
  - QR(11) = {1, 3, 4, 5, 9} (index 2 subgroup)
  - -1 = 10 (mod 11) is a NON-QR
  - If all prime factors of x_2 are QRs, H ⊆ QR(11)
  - Obstruction: 10 ∉ QR(11), so no witness

THE PATTERN:
  The 14 K13 failures are exactly primes p where, for k=0,1,2:
  - All prime factors of x_k lie in a proper subgroup H of (Z/m_k)*
  - -1 ∉ H
  - Therefore no divisor d of x_k² can satisfy d ≡ -x_k (mod m_k)

This is why GPT's Dirichlet character theory works: the character kernel
IS the subgroup H, and the obstruction is -1 not being in that kernel.
""")

def what_would_break_obstruction():
    """
    Analyze what property an x_k would need to break the obstruction.
    """
    print("\n" + "=" * 80)
    print("WHAT BREAKS THE OBSTRUCTION?")
    print("=" * 80)

    print("""
For an x_k to have a witness, we need -1 ∈ H(x_k).

For k=0 (m=3): Need a prime factor q with q ≡ 2 (mod 3)
For k=1 (m=7): Need a prime factor q that's a NON-QR mod 7, i.e., q ≡ 3,5,6 (mod 7)
For k=2 (m=11): Need a prime factor q that's a NON-QR mod 11, i.e., q ≡ 2,6,7,8,10 (mod 11)

The 14 failures are special because their x_k values avoid ALL such primes
for k=0,1,2 simultaneously. This is a very rare condition.

For k ≥ 3 in K13, the moduli m_k are larger, and the probability of
all prime factors lying in a proper subgroup drops. But for the failures,
this alignment persists across all 13 values of k!
""")

    # Check a few specific cases
    print("\nVerifying on first failure p=10170169:")
    p = 10170169
    for k in [0, 1, 2]:
        xk = x_k(p, k)
        mk = M_K[k]
        facts = factor(xk)

        print(f"\n  k={k}, m={mk}, x_k={xk}")
        print(f"  Factors: {facts}")

        for q, e in facts:
            r = q % mk
            if mk == 3:
                in_kernel = (r == 1)
                desc = "≡ 1 (mod 3)" if in_kernel else "≡ 2 (mod 3)"
            else:
                # Check if QR
                leg = pow(q, (mk-1)//2, mk)
                is_qr = (leg == 1)
                in_kernel = is_qr
                desc = f"QR mod {mk}" if is_qr else f"non-QR mod {mk}"

            print(f"    {q} ≡ {r} (mod {mk}): {desc} → {'IN kernel' if in_kernel else 'ESCAPES kernel'}")

if __name__ == "__main__":
    analyze_obstruction_structure()
    show_character_connection()
    what_would_break_obstruction()
